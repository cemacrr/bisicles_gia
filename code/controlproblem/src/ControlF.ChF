#include "CONSTANTS.H"
#include "IceConstants.H"

c---------------------------------------------------
c contribution to the right hand side of the  
c ssa/l1l2 adjoint equations due to mismatch
c between model and observed *speeds* um and uo 
c (not velocity)
c
c rhs[x] = (uo/um - 1)*ux
c rhs[y] = (uo/um - 1)*uy
c
c rhs <- contribution
c misfit <- (uo - um)**2
c umx,umy -> model velocity components
c uox,uoy -> observed velocity components. so long 
c as the observed speed is uo = (uox^2 + uoy^2)**(1/2),
c it doesn't matter what lives in these 
c---------------------------------------------------
      subroutine adjrhsspeedctrl( CHF_FRA1[rhsx],CHF_FRA1[rhsy], 
     &     CHF_FRA1[misfit],
     &     CHF_CONST_FRA1[umx],CHF_CONST_FRA1[umy],
     &     CHF_CONST_FRA1[uox],CHF_CONST_FRA1[uoy],
     &     CHF_BOX[box] )

      integer CHF_AUTODECL[i]
      REAL_T uo,um,t

      CHF_AUTOMULTIDO[box; i]
      uo = (uox(CHF_AUTOIX[i])**two + uoy(CHF_AUTOIX[i])**two)**half
      um = (umx(CHF_AUTOIX[i])**two+umy(CHF_AUTOIX[i])**two)**half
      
      misfit(CHF_AUTOIX[i]) = (uo-um)**two
c      misfit(CHF_AUTOIX[i]) = (uo-um)
      t = (uo/(TINY_NORM + um)-1.0)
      rhsx(CHF_AUTOIX[i]) = t * umx(CHF_AUTOIX[i])
      rhsy(CHF_AUTOIX[i]) = t * umy(CHF_AUTOIX[i])
 
      CHF_ENDDO

      return
      end

c-----------------------------------------------------
c contribution to the right hand side of the  
c ssa/l1l2 adjoint equations due to mismatch
c between model and observed div(UH)
c
c rhs[x] = thck * d/dx (misfit)
c-------------------------------------------------------
      subroutine adjrhsmassctrl( CHF_FRA[rhs], 
     &     CHF_FRA1[misfit],CHF_CONST_FRA1[thck],
     &     CHF_CONST_REAL[dx], CHF_BOX[box])

      integer CHF_AUTODECL[i]
      integer CHF_DDECL[ip;jp;kp]
      integer dir,ndir
      REAL_T oneontwodx

      oneontwodx = half / dx
      ndir = CHF_DSELECT[1;2;3]     
      do dir =0,ndir-1

         CHF_DTERM[
         ip = CHF_ID(0,dir);
         jp = CHF_ID(1,dir);
         kp = CHF_ID(2,dir)]

         CHF_AUTOMULTIDO[box; i]

         rhs(CHF_AUTOIX[i],dir) =  thck(CHF_AUTOIX[i]) * oneontwodx 
     &        * (misfit(CHF_IX[i0+ip;i1+jp;i2+kp]) 
     &        - misfit(CHF_IX[i0-ip;i1-jp;i2-kp])) 
         
         CHF_ENDDO
      end do
      return
      end


c----------------------------------------------------
c x <- x * exp(min(a,max(-b,a)))
      subroutine boundexpctrl( 
     &     CHF_FRA1[x],CHF_CONST_FRA1[a],
     &     CHF_CONST_REAL[b],CHF_BOX[box])

      integer CHF_AUTODECL[i]
      REAL_T t

      CHF_AUTOMULTIDO[box; i]
      t = min(b,max(a(CHF_AUTOIX[i]),-b))
      x(CHF_AUTOIX[i]) = x(CHF_AUTOIX[i]) * exp(t)
      CHF_ENDDO
      return
      end

c----------------------------------------------------
c x <- x * exp(a)
      subroutine expctrl( 
     &     CHF_FRA1[x],
     &     CHF_CONST_FRA1[a],
     &     CHF_BOX[box])

      integer CHF_AUTODECL[i]

      CHF_AUTOMULTIDO[box; i]
      x(CHF_AUTOIX[i]) = x(CHF_AUTOIX[i]) 
     &     * exp(a(CHF_AUTOIX[i]))
      CHF_ENDDO
      return
      end

c----------------------------------------------------
c x <- (min(b,max(-b,x)))
      subroutine boundctrl( 
     &     CHF_FRA1[x],
     &     CHF_CONST_REAL[b],CHF_BOX[box])

      integer CHF_AUTODECL[i]
      REAL_T t

      CHF_AUTOMULTIDO[box; i]
      t = x(CHF_AUTOIX[i])
      x(CHF_AUTOIX[i]) = min(b,max(-b,t))
      CHF_ENDDO
      return
      end

c--------------------------------------------------------
c barrier penalty p and its gradient g
c p = -ln( (x+b+tol)*(b+tol-x) / b^2), where b > 0
c g = -{1/(x+b+tol) + 1/(x-b-tol)} 
      subroutine gradbarrierctrl(
     &     CHF_FRA1[p],
     &     CHF_FRA1[g],
     &     CHF_CONST_FRA1[x],
     &     CHF_CONST_REAL[b],
     &     CHF_CONST_REAL[tol],
     &     CHF_BOX[box])

      integer CHF_AUTODECL[i]
      REAL_T xx,dm,dp,bsq
      bsq = b**2

      CHF_AUTOMULTIDO[box; i]
      xx = x(CHF_AUTOIX[i])
      if (xx.le.-b) then
         xx = -b+tol
      else if (xx.ge.b) then
         xx = b-tol
      end if
      dm = xx+b+tol
      dp = xx-b-tol

      p(CHF_AUTOIX[i]) = - log(- dp * dm / bsq)
      g(CHF_AUTOIX[i]) = - one / dm - one / dp 
      CHF_ENDDO

      return
      end
