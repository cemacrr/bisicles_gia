c---------------------------------------------------
c set C = C0 in cells with mu(sum over faces) < mu0 
c and C < C0
c--------------------------------------------------

      subroutine enforcewellposedcell(CHF_FRA1[C],
     &     CHF_CONST_FRA1[mux], CHF_CONST_FRA1[muy],
     &     CHF_CONST_REAL[mu0], CHF_CONST_REAL[C0],
     &     CHF_BOX[box])


       integer CHF_AUTODECL[i]
       integer CHF_AUTODECL[ix]
       integer CHF_AUTODECL[iy]
     
       Real_T musum

       CHF_DTERM[ix0 = CHF_ID(0,0);
                 ix1 = CHF_ID(0,1);
                 ix2 = CHF_ID(0,2)]

      CHF_DTERM[iy0 = CHF_ID(1,0);
                iy1 = CHF_ID(1,1);
                iy2 = CHF_ID(1,2)]          
                
      CHF_AUTOMULTIDO[box; i]
      if (C(CHF_AUTOIX[i]).lt.C0) then
         musum = mux(CHF_AUTOIX[i]) +  mux(CHF_OFFSETIX[i;+ix]) 
     &        +  muy(CHF_AUTOIX[i]) +  muy(CHF_OFFSETIX[i;+iy])
         
         if (musum.lt.mu0) then
            C(CHF_AUTOIX[i]) = C0
         end if
      end if
      CHF_ENDDO
      return
      end


c---------------------------------------------------
c a <- (cond mask == m, b, a)
c ------------------------------------------------

      subroutine maskedreplace(CHF_FRA1[a],
     &     CHF_CONST_FRA1[b],
     &     CHF_CONST_FIA1[mask],
     &     CHF_CONST_INT[m],
     &     CHF_BOX[box])

      integer CHF_AUTODECL[i]
      CHF_AUTOMULTIDO[box; i]
         if (mask(CHF_AUTOIX[i]).eq.m) then
            a(CHF_AUTOIX[i]) =  b(CHF_AUTOIX[i])
         end if
      CHF_ENDDO
      
      return
      end

c--------------------------------------------------
c piecewise linear interpolation of a(x) with
c abscissae xn and ordinates bn. dx and db are
c workspaces 
c--------------------------------------------------
      subroutine pwlfill(CHF_FRA1[a],
     &     CHF_CONST_FRA1[x],
     &     CHF_CONST_VR[xn],
     &     CHF_CONST_VR[bn],
     &     CHF_VR[dx],
     &     CHF_VR[db],
     &     CHF_BOX[box])

      integer CHF_AUTODECL[i], m, n
      Real_T xi

      do m = 0, ixnhi0 - 1
         dx(m) = xn(m+1) - xn(m)
         db(m) = bn(m+1) - bn(m)
      end do

      CHF_AUTOMULTIDO[box; i]
      xi = x(CHF_AUTOIX[i])
      if (xi .lt. xn(0)) then
         a(CHF_AUTOIX[i]) = bn(0)
      else if (xi .ge. xn(ixnhi0)) then
         a(CHF_AUTOIX[i]) = bn(ixnhi0)
      else
         do m = 0, ixnhi0-1
            if ( xi.lt.xn(m+1) ) then
               a(CHF_AUTOIX[i]) = bn(m) + db(m)* (xi - xn(m))/dx(m)
               exit
            end if
         end do
      end if
      CHF_ENDDO


      return
      end

      subroutine abslimitfab(CHF_FRA[u], 
     &     CHF_CONST_REAL[limit], 	
     &     CHF_BOX[box])
      
      integer CHF_AUTODECL[i], n
      REAL_T abslim

      abslim = limit
      do n  = 0, CHF_NCOMP[u]-1
         CHF_AUTOMULTIDO[box; i]
         if (u(CHF_AUTOIX[i],n).lt.zero) then
            u(CHF_AUTOIX[i],n) = max(u(CHF_AUTOIX[i],n),-abslim)
         else
            u(CHF_AUTOIX[i],n) = min(u(CHF_AUTOIX[i],n),abslim)
         end if
         CHF_ENDDO
      end do
      return
      end
	
      subroutine minfab(CHF_FRA[u], 
     &     CHF_CONST_REAL[limit], 	
     &     CHF_BOX[box])
      
      integer CHF_AUTODECL[i],n
      do n  = 0, CHF_NCOMP[u]-1
         CHF_AUTOMULTIDO[box; i]
         u(CHF_AUTOIX[i],n) = min(u(CHF_AUTOIX[i],n),limit)
         CHF_ENDDO
      end do
      return
      end      
      
      subroutine maxfab(CHF_FRA[u], 
     &     CHF_CONST_REAL[limit], CHF_BOX[box])
      
      integer CHF_AUTODECL[i],n
      do n  = 0, CHF_NCOMP[u]-1
         CHF_AUTOMULTIDO[box; i]
         u(CHF_AUTOIX[i],n) = max(u(CHF_AUTOIX[i],n),limit)
         CHF_ENDDO
      end do
      return
      end 

c------------------------------------------------------------
c flag cells ok == 1 where alpha > tol or either face mu > tol
c-----------------------------------------------------------
      subroutine checkcoef(CHF_FIA1[ok],
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_FRA1[mu],
     &     CHF_CONST_FRA1[alpha],
     &     CHF_CONST_REAL[mumin],
     &     CHF_CONST_REAL[alphamin],
     &     CHF_BOX[box])
      
      integer CHF_AUTODECL[i]
      integer CHF_AUTODECL[ii]
      CHF_DTERM[ii0 = CHF_ID(dir,0);
                ii1 = CHF_ID(dir,1);
                ii2 = CHF_ID(dir,2)]

      CHF_AUTOMULTIDO[box; i]
      if (alpha(CHF_AUTOIX[i]).gt.alphamin) then
         ok(CHF_AUTOIX[i]) = 1
      else if (mu(CHF_AUTOIX[i]).gt.mumin) then
         ok(CHF_AUTOIX[i]) = 1
      else if (mu(CHF_OFFSETIX[i;+ii]).gt.mumin) then
         ok(CHF_AUTOIX[i]) = 1
      end if

      CHF_ENDDO
      
      return
      end 

      subroutine applyminviscosity(CHF_FRA1[mu],
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_FRA1[faceH],
     &     CHF_CONST_FIA1[ok],
     &     CHF_CONST_REAL[mumin],
     &     CHF_BOX[box])

      integer CHF_AUTODECL[i]
      integer CHF_AUTODECL[ii]

      CHF_DTERM[ii0 = CHF_ID(dir,0);
                ii1 = CHF_ID(dir,1);
                ii2 = CHF_ID(dir,2)]

       CHF_AUTOMULTIDO[box; i]
      if (ok(CHF_AUTOIX[i]).ne.1) then
         if (faceH(CHF_AUTOIX[i]).gt.1.0d-10) then
            mu(CHF_AUTOIX[i]) = 
     &           max(mu(CHF_AUTOIX[i]), mumin);
         end if
         if (faceH(CHF_OFFSETIX[i;+ii]).gt.1.0d-10) then
            mu(CHF_OFFSETIX[i;+ii]) = 
     &           max(mu(CHF_OFFSETIX[i;+ii]), mumin);
         end if
      end if

      CHF_ENDDO

      return
      end
