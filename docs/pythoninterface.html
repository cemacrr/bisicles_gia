<html>
<head>
  <title>BISICLES Python Interface</title>
</head>
<body>
<h1>BISICLES Python Interface</h1>
<p>
<strong>The Python Interface is new and might change. You might need 
change your python function prototypes as it evolves.</strong>
</p>

<p>BISICLES' python interface is intended to make some of less performance intensive
parts of BISICLES easier to program. It is fairly crude : at certain points during a run BISICLES 
will use an embedded python interpreter to evaluate various fields. At the moment, it is possible to
specify <a href='#flux'>surface 
fluxes</a> (that is, accumulation and melting), the <a href='#ibc'>initial geometry</a> (topography and thickness), and the <a href='#btrc'>basal traction coefficient</a>. 
The most likely application of the Python
interface is in defining idealized problems, where the use of the <a href='leveldatainterface'>LevelData interface</a>
would lead to undesirable numerical error</p> 

<p>You should have included the python interface when <a href='readme.html'>building BISICLES</a>, otherwise
you will need to do so. You will need to run the appropriate <a href='readme.html#makeclean'>make clean</a></p>

<p>To run BISCICLES with the python interface, you need to ensure that the environment variable PYTHONPATH
inlcudes the directory where your python modules (.py files) are stored. If this is the working directory, 
then in serial, run BISICLES like so
<pre>
PYTHONPATH=`pwd` driver2d.Linux.64.mpic++.gfortran.DEBUG.OPT.ex inputs.file sout.0 2>err.0 &
</pre>
and in parallel, assuming 4 processors, 
<pre>
nohup mpirun -np 4 -x PYTHONPATH=`pwd` driver2d.Linux.64.mpic++.gfortran.DEBUG.OPT.MPI.ex inputs.file &
</pre>
</p>

<h2><a name='flux'>Surface Fluxes</a></h2>

To specify a <a href='surfaceflux.html'>surface flux</a> through a python function write
a python function that takes five scalar arguments (x,y,t,thickness,topography).
Let's say that you have created a file foo.py
<pre>
#file my.py
def acab(x,y,t,thck,topg):
    return 1.0e-3 * (thck + topg)
</pre>
then you would include lines like
<pre>
surfaceFlux.type = pythonFlux
surfaceFlux.module = foo
surfaceFlux.function = acab
</pre>
in the input file.


<h2><a name='ibc'>Initial Geometry and boundary conditions</a></h2>

To set the initial thickness and topography using python functions, create a python
module contain two scalar functions of (x,y), e.g
<pre>
#file foo.py
def thck(x,y):
     return 1.5e+2

def topg(x,y):
    return -1.0e+2 - x/1.0e+3
</pre>
and specify it in the configuration file like so
<pre>
geometry.problem_type = Python
PythonIBC.module = foo
PythonIBC.thicknessFunction = thck
PythonIBC.topographyFunction = topg
</pre>
x and y are double precision floating point numbers, they are given in meters, and will
correspond to the centers of cells. Note that they will be on the BISICLES co-ordinate system, ie
the bottom left corner of the mesh is (0,0)
</p>

<p>
The choice of <pre>geometry.problem_type = Python</pre> implies <strong>boundary conditions as well as initial conditions</strong>.
By default, reflection boundary conditions (ice divides) are imposed on all four domain edges. This can
be changed to periodic boundary conditions in the usual way, e.g
<pre>
amr.is_periodic = 0 1 0
</pre>
selects reflection boundaries at the x-faces of the domain, but periodic boundaries at the y-faces.
To set a marine boundary condition, use DomainEdgeCalvingModel, e.g
<pre>
CalvingModel.type = DomainEdgeCalvingModel
CalvingModel.front_hi = 1 0    #impose a marine boundary at the high x-face 
CalvingModel.front_lo = 0 0
</pre>
Alternatively, it is possible to maintain a calving front inside the domain by set a large negative accumulation:
Adding a function
<pre>
#file foo.py
def melt(x,y,t,thck,topg):
    melt = 0.0
    if (x^2 + y^2 > 1.0e+12):
      melt = -1.0e+3
    return melt
</pre>
to a python module and the configuration lines
<pre>
basalFlux.type = pythonFlux
basalFlux.module = foo
basalFlux.function = melt
</pre>
would lead to a quarter-circular calving front centered on the bottom left corner with radius 1000 km
</p>

<h2><a name='btrc'>Basal Friction Coefficient</a></h2>
<p>
You can specify a basal friction coefficient in much the same way as a surface flux, e.g
add 
<pre>
#file foo.py
import math

def friction(x,y,t,thck,topg):
    friction = 1.01e+3 + 1.0e+3 * math.sin(x * 1.0e+3)*math.sin(y * 1.0e+3)
    return friction   
</pre>
in a python module and 
<pre>
geometry.beta_type = Python
PythonBasalFriction.module = foo
PythonBasalFriction.function = friction
</pre>
in the configuration file.
</p>
</body>
</html>
