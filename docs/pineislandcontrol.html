 <html>
<head>
  <title>
    BISICLES Pine Island Glacier control problem
  </title>
<head>
<body>
  <H1>BISICLES Pine Island Glacier control problem</H1>
  <p> These instructions assume that you have working BISICLES executables, including control, driver 
     and nctoamr. If that is not the case, there are some <a href='../readme.html'>BISICLES build instructions</a>
     Anne Le Brocq has provided us with the data for this application - thanks Anne. You also
    need to have followed at least the preprocessing step of the first <a href='pineisland.html'>Pine Island Glacier example</a>,
    up to the point where you create the file &quot;pig-bisicles-1km.2d.hdf5&quot;
  </p> 

  <p>
    The configuration file for the example, inputs.pig.ctrl, 
    is located in $BISICLES_HOME/BISICLES/examples/PineIslandGlacier. 
    The control problem is run in a similar way to the time dependent problem, 
    but using a different binary, e.g
    <pre>
> nohup mpirun -np 6 $BISICLES_HOME/BISICLES/code/controlproblem/control2d.Linux.64.mpic++.gfortran.DEBUG.OPT.MPI.ex inputs.pig.ctrl &
    </pre>
    Just as with driver, control writes its log output to stdout in serial and to file called pout.0, pout.1, ... when run
    in parallel. Most of the computational effort is spent solving the stress-balance equations and adjoint stress-balance
    equations.
  </p>

  <p>
    BISICLES control problem uses a conjugate gradient (CG) method to minimise its objective function.
    You can check the progress of the CG iterations by filtering all but a few lines from the log output,
    e.g
<pre>
> grep CG pout.0
CGOptimize iteration 0 ||f'(x)||^2 = 2.36963e+21 ||f(x)||^2 = 2.26676e+21
CGOptimize iteration 1 ||f'(x)||^2 = 2.21975e+20 ||f(x)||^2 = 1.75425e+20
CGOptimize iteration 2 ||f'(x)||^2 = 1.60844e+20 ||f(x)||^2 = 2.82808e+19
CGOptimize iteration 3 ||f'(x)||^2 = 1.23018e+20 ||f(x)||^2 = 1.43319e+19
CGOptimize iteration 4 ||f'(x)||^2 = 6.21429e+19 ||f(x)||^2 = 1.35264e+19
CGOptimize iteration 5 ||f'(x)||^2 = 1.62043e+20 ||f(x)||^2 = 9.50168e+18
CGOptimize iteration 6 ||f'(x)||^2 = 6.71202e+19 ||f(x)||^2 = 7.0279e+18
CGOptimize iteration 7 ||f'(x)||^2 = 4.56953e+19 ||f(x)||^2 = 6.35532e+18
CGOptimize iteration 8 ||f'(x)||^2 = 4.79926e+19 ||f(x)||^2 = 5.30343e+18
CGOptimize iteration 9 ||f'(x)||^2 = 3.13159e+19 ||f(x)||^2 = 4.83152e+18
CGOptimize restart k = 10 beta = 0.973268
CGOptimize iteration 10 ||f'(x)||^2 = 3.11792e+19 ||f(x)||^2 = 4.35833e+18
CGOptimize iteration 11 ||f'(x)||^2 = 1.42901e+19 ||f(x)||^2 = 3.8504e+18
CGOptimize iteration 12 ||f'(x)||^2 = 1.61132e+19 ||f(x)||^2 = 3.57307e+18
CGOptimize iteration 13 ||f'(x)||^2 = 1.4499e+19 ||f(x)||^2 = 3.17816e+18
CGOptimize iteration 14 ||f'(x)||^2 = 1.54589e+19 ||f(x)||^2 = 2.82274e+18
CGOptimize iteration 15 ||f'(x)||^2 = 1.60211e+19 ||f(x)||^2 = 2.42492e+18
CGOptimize iteration 16 ||f'(x)||^2 = 1.2018e+19 ||f(x)||^2 = 2.18363e+18
</pre>
    The quantity ||f(x)||^2 is the objective function itself, which ought to decay 
    quite rapidly at first. After a while, its rate of improvement slows down - this
    stage usually corresponds to &quot;overfitting&quot;, where higher frequency
    components creep into the solution.
  <p>
    <p>
      A file is written at the end of every CG iteration which contains the current
      estimate of the solution. These are currently named like ControlOuter%06.2d.hdf5
      (e.g ControlOuter000002.2d.hdf5 at the end of iterations zero). The most useful
      are the observed and modelled velocities (velox,veloy) and (velbx,velby), and
      the solution  muCoef (the coefficient of viscosity) and C (the basal traction coefficient).
      The latter two need to be extracted and written to a flat file, and can then
      be read (through the <a href='leveldatainterface.html'>LevelData interface</a>)
      by the main executable (driver).
    <p>

</body>
